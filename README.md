# Defects4J Case Studies

## Repository organization
The purpose of each directory in this repository:

- `auto_repairer`: Automatic repair tool version used in this study
- `d4j_projects`: Project directories for each case study (downloaded with `download_d4j_projects.sh`)
- `diffs`: File versions before and after the mutation opposing the fix
- `generated_patches`: Patches generated by the different repair strategies for each case study
- `inferred`: Files listing the mutation operators that got inferred by *Morpheus* for every considered case study in the *Defects4J* repository
- `logs`: Repair process log files
- `morpheus`: Holds the Morpheus version used in this study
- `sfl_reports`: SFL reports generated for the case studies

Scripts description:

- `changed_files.sh`: Extracts the changed files from the commit opposing the fix
- `download_d4j_projects.sh`: Downloads each case study's project into the `d4j_projects` directory and checks out the buggy commit
- `find_fix.sh`: Helper script to locate intended fixes for a specific case study
- `fix_visualizer.sh`: Helper script to locate intended fixes for all case studies (makes use of `find_fix.sh`)
- `generate_patches.sh`: Runs the repair tool for all case studies and places the produced patches in the `generated_patches` directory
- `infer_all.sh`: Infers mutation operators for all case studies (makes use of `infer_mut_ops.sh`
- `infer_mut_ops.sh`: Uses *Morpheus* to analyze the file versions in a given directory and places the produced reports with all the detected mutation operators for a single case study in the specified output directory (used by `infer_all.sh` which calls this script with the appropriate arguments)


## Case Studies with Real Bugs
There are 5 case studies consisting of real bugs which we think are interesting to explore. The corresponding bug IDs are:

- **Closure_18b** - [*Closure*](https://github.com/google/closure-compiler)
- **Closure_168b**
- **Closure_62b**
- **Closure_73b**
- **Lang_6b** - [*Apache Commons Lang*](https://github.com/apache/commons-lang)

To replicate what was documented in the paper, run the following command to download and check out the buggy commit of each case study (needs [Defects4J](https://github.com/rjust/defects4j)):

        bash download_d4j_projects.sh

### Checking the fix

If you `cd` into a case study's directory (e.g. `cd d4j_projects/Closure_18b`) and you wish to see the *diff* which fixed that bug, you can run:

        git diff HEAD HEAD~1

This will show and highlight the change that fixed the bug in question. Note that, because we checked out the buggy commit, *Defects4J's* data curation places the fix commit (`HEAD~1`) before the buggy commit (`HEAD`).

### Checking the bug

The initial setup checks out each case study's buggy version.

Similarly to *Bugswarm*, *Defects4J*  does a good job isolating the fix. However, we have to do some work to find the commit responsible for introducing the change which causes the bug. Moreover, that commit may not necessarily cause the software to fail its tests. The file `info/bug_intro.txt` lists (for each case study) the offset to go back in the commit history where we detected a transformation that opposes the fix.
As an example, the line for the first case study:

        Closure_18b 232

has `232` as the offset (last field). If we execute:

        git diff HEAD~<offset+1> HEAD~<offset>

we get a *diff* in which we need to reverse one of the changes to fix the bug.

With this, our aim is to show that the cause for a bug may be further back in a project's version history.

### Generating the SFL report

The tool [*GZoltar*](https://github.com/GZoltar/gzoltar) was used to generate the SFL report for each bug.

For convenience, the generated SFL reports are available in the `sfl_reports` directory.

### Inferring mutations with [*Morpheus*](https://github.com/FranciscoRibeiro/morpheus)

For each bug, the modified files can be located in the corresponding `next` and `previous` directories. As an example, for the first case study:

- `diffs/Closure_18b/previous` --- contains the files **before** the bug
- `diffs/Closure_18b/next` --- contains the **after** the introduction of the bug

The script `changed_files.sh` can be used to extract these files. Using the first case study as an example:

		bash changed_files.sh d4j_projects/Closure_18b/ 232 diffs/Closure_18b

We recall that *Morpheus* can be used to analyze the changes made to the files and infer the mutation operators behind the modifications, like this:

        java -jar morpheus/morpheus.jar <before_file> <buggy_file>

As an example, to infer the semantics of the changes responsible for introducing the bug in the first case study:

        java -jar morpheus/morpheus.jar \
        diffs/Closure_18b/previous/src/com/google/javascript/jscomp/Compiler.java \
        diffs/Closure_18b/next/src/com/google/javascript/jscomp/Compiler.java

However, this assumes we already know the change we are interested in analyzing is from that specific file.
In reality, we need to run *Morpheus* over every modified file.

For convenience, executing:

		bash infer_all.sh

will analyze every modified file of every case study and place the results in the appropriate sub-directory inside `inferred` (it will be emptied and repopulated).

Continuing with the same example, the output from the first case study can be seen in `inferred/Closure_18b.csv`

If we wish to run the inference step just for that case study:

		bash infer_mut_ops.sh diffs/Closure_18b morpheus/morpheus.jar inferred/Closure_18b.csv

### Repairing the case studies

We implemented a [mutation-based repair tool](https://github.com/FranciscoRibeiro/auto_repairer) which can interpret the information produced by *Morpheus*.

Still using the previous case study as an example, let us execute the repair tool using the strategy that considers both lines and columns where mutations were inferred (see the [repair tool's repo](https://github.com/FranciscoRibeiro/auto_repairer) for more details about each repair strategy and other arguments):

		java -jar auto_repairer/auto_repairer.jar \
			d4j_projects/Closure_18b \
			d4j_projects/Closure_18b/src \
			generated_patches/Closure_18b/ms \
			-ms \
			inferred/Closure_18b.csv

To execute the described steps and generate the patches for every case study at once:

		bash generate_patches.sh

Note that the `generated_patches` directory is already populated with the candidate patches the repair tool generated, as we describe in the case studies report. Executing the script deletes these patches and recreates them by running the repair tool with different strategies. 

